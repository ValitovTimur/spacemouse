# SpaceMouse (fork): 6‑DOF мышь с 8 Hall‑датчиками и 5 кнопками (без энкодера и подсветки)

**Этот репозиторий — форк** проекта `AndunHH/spacemouse`.

**Целевой стенд:** Arduino Pro Micro (ATmega32U4, 5 V / 16 MHz) + **8 линейных Hall‑датчиков**, **5 физических кнопок** (3 базовые + Fn1 + Fn2). **Энкодера нет. LED‑кольца нет.**

**USB/HID API и формат отчётов полностью совместимы с апстримом** (эмуляция *SpaceMouse Pro Wireless (wired)*). Параметр‑меню, EEPROM и ProgMode по UART сохранены.

---

## Что изменено относительно апстрима

Репозиторий упрощён:

* Оставлены каталоги: **`spacemouse-keys/`**, **`testConfig/`**, **`Reverse-Engineering-Docs/`**, **`modifierFunctions/`**.
* Скрипты/утилиты, не влияющие на текущую сборку, удалены.

Изменения в коде (минимально инвазивно, без ломки API):

* **`spacemouse-keys/config.h`**

  * Профиль аппаратуры «8 Hall + 5 кнопок, без энкодера/LED».
  * Добавлены две новые кнопки в `KEYLIST` и увеличены `NUMKEYS`/`NUMHIDKEYS`.
  * Добавлены индексы модификаторов: `KEY_FN1_IDX`, `KEY_FN2_IDX`.
  * Введены три слоя раскладки HID‑кодов:

    * `BUTTONLIST` — базовый (1/2/3 и соло‑функции Fn).
    * `BUTTONLIST_FN1` — слой для комбо `Fn1 + [1|2|3]`.
    * `BUTTONLIST_FN2` — слой для комбо `Fn2 + [1|2|3]`.
  * Блок чувствительностей/инверсий/гейтов — по реальным замерам из консольного меню (`param::…`).

* **`spacemouse-keys/SpaceMouseHID.cpp`**

  * Переписана **`prepareKeyBytes()`**: корректная обработка **комбинаций** (Fn1/Fn2 + 1/2/3) **без «проскока» базовых кнопок** и **без «сдвоений»**.
  * Удержание (hold) любой кнопки/комбинации корректно **повторяет HID‑репорты** (для Shift/Ctrl/и т.п. на стороне ПК).

> HID‑дескриптор и идентификаторы устройства **не менялись** — драйверы 3Dconnexion/spacenavd видят устройство как раньше.

---

## Аппаратный профиль

* MCU: ATmega32U4 (Pro Micro, 5 V/16 MHz, Caterina).
* Датчики: 8 × линейных Hall (+ магниты/TPU пружины).
* Кнопки: 5 шт. (3 базовые + Fn1 + Fn2).
* Энкодер: **нет**.
* LED/Neopixel: **нет**.

---

## Структура репозитория

```
spacemouse-keys/              ← основной скетч, HID, калибровка, меню, конфиг
  ├─ spacemouse-keys.ino
  ├─ SpaceMouseHID.{h,cpp}    ← HID, сборка битов кнопок (patched)
  ├─ spaceKeys.{h,cpp}        ← чтение/дребезг/состояния клавиш (API без изменений)
  ├─ calibration.{h,cpp}
  ├─ kinematics.{h,cpp}
  ├─ parameterMenu.{h,cpp}
  ├─ config.h                  ← профиль этого форка (patched)
  └─ release.h

testConfig/
Reverse-Engineering-Docs/
modifierFunctions/
```

---

## Сборка и прошивка (Arduino IDE)

1. **Установить пакет SparkFun AVR Boards**
   Arduino IDE → *Board Manager* → найти **SparkFun AVR Boards** → *Install*.

2. **Заменить `boards.txt` из этого форка**
   В корне репозитория лежит `boards.txt`. Скопируй его **поверх** одноимённого файла в директории установленного пакета SparkFun AVR Boards (путь зависит от ОС/IDE), затем **перезапусти Arduino IDE**.

   Примеры путей:

   * **Windows (IDE 2.x):** `C:\Users\<user>\AppData\Local\Arduino15\packages\SparkFun\hardware\avr\<version>\boards.txt`
   * **Windows (IDE 1.8.x portable):** `<Arduino>\hardware\SparkFun\avr\boards.txt`
   * **Linux:** `~/.arduino15/packages/SparkFun/hardware/avr/<version>/boards.txt`
   * **macOS:** `~/Library/Arduino15/packages/SparkFun/hardware/avr/<version>/boards.txt`

3. **Открыть проект**
   `spacemouse-keys/spacemouse-keys.ino`.

4. **Выбрать плату и порт**
   Tools → Board → **SparkFun AVR Boards → Spacemouse (ATmega32U4, 5 V, 16 MHz)**.
   Tools → Port → выбрать твой COM/tty.

5. **Собрать и прошить**
   Нажать **Upload**. Если IDE не поймала окно бутлоадера, дважды быстро нажми **Reset** на Pro Micro (режим Caterina) и повтори Upload.

6. **Проверка через Serial** (необязательно)
   Открой Serial Monitor (115200 бод). Меню отладок/параметров — пункт **30**.

> **Важно:** конфигурация (`config.h`), терминальное меню (30), ProgMode и Serial‑API — **без изменений** и полностью совместимы с апстримом.

---

## Конфигурация: ключевые фрагменты

Ниже — выдержка из рабочего `config.h`. HID‑API полностью совместим с апстримом; расширение — только в части 5 кнопок и Fn‑слоёв.

```c
// Кол-во и пины физических кнопок
#define NUMKEYS    5
#define KEYLIST    {0, 1, 2, 14, 16}   // 3 базовые + Fn1 + Fn2 (под твои GPIO)

// Сколько HID-кнопок реально репортим (биты в 4 байтах отчёта)
#define NUMHIDKEYS 5

// Индексы Fn-кнопок в keyState[] (по порядку из KEYLIST)
#define KEY_FN1_IDX 3
#define KEY_FN2_IDX 4

// Базовый слой (без Fn): 1,2,3 + соло-действия Fn
#define BUTTONLIST      {SM_2,   SM_1,   SM_3,   SM_SHFT, SM_4}

// Слой Fn1: Fn1 + 1/2/3 → альтернативные коды
#define BUTTONLIST_FN1  {SM_FIT, SM_MENU, SM_ROT, SM_SHFT, SM_4}

// Слой Fn2: Fn2 + 1/2/3 → ещё один набор кодов
#define BUTTONLIST_FN2  {SM_CTRL, SM_ESC,  SM_ALT, SM_SHFT, SM_4}
```

Поведение:

* **Одиночная 1/2/3** — отправляется базовый HID‑код.
* **Fn1/Fn2 + 1/2/3** — отправляется **только** код из соответствующего Fn‑слоя (без лишнего базового клика).
* **Fn1/Fn2 в одиночку** — их соло‑действия берутся из `BUTTONLIST` (в примере: `SM_SHFT` и `SM_4`).
* **Удержание** кнопок/комбинаций — HID‑репорты продолжают идти (repeat/hold работает).

Остальной `config.h` (DEADZONE, MIN/MAX, чувствительности, инверсии, дрейф‑компенсация) — по апстриму, значения выставлены по замерам целевого девайса.

---

## Совместимость

* **USB/HID отчёты** идентичны апстриму — драйверы 3Dconnexion (Windows/macOS) и **spacenavd** (Linux) принимают устройство без изменений.
* **Параметр‑меню / EEPROM / ProgMode** — без изменений (меню `30` в сериалке; команды `>p`, `>r`, `>w`, `>s` и т.д.).

---

## Патч‑лист (файлы)

* `spacemouse-keys/config.h`

  * Расширение до 5 кнопок (`NUMKEYS`, `KEYLIST`, `NUMHIDKEYS`).
  * Добавлены `KEY_FN1_IDX`, `KEY_FN2_IDX`.
  * Добавлены `BUTTONLIST`, `BUTTONLIST_FN1`, `BUTTONLIST_FN2`.
  * Обновлены калибровки и чувствительности по реальным замерам.

* `spacemouse-keys/SpaceMouseHID.cpp`

  * Переписана `prepareKeyBytes()` под Fn‑слои; убраны «двойные» клики; корректен hold (повторение отчётов).

> Остальные исходники — как в апстриме; интерфейсы/структуры не менялись.

---

## Известные ограничения

* По умолчанию **отключены** энкодер и LED‑подсветка (можно включить обратно через `config.h`, но профиль форка — «8 Hall + 5 кнопок»).
* При увеличении числа кнопок: обновляйте `NUMKEYS`, `KEYLIST`, `NUMHIDKEYS` и все слои; следите, чтобы индексы Fn указывали на реальные позиции в `KEYLIST`.

---

## Лицензия и атрибуция

Лицензия наследована от апстрима: **CC BY‑NC‑SA 4.0**.

Апстрим: `AndunHH/spacemouse`. 3Dconnexion к проекту не аффилирована; USB‑протокол восстановлен обратной разработкой сообществом.

## Наладка и калибровка (c нуля до «ездит как надо»)

> Целевая аппаратная конфигурация этого форка: **8 HES**, **без энкодера/подсветки**, **5 кнопок (1/2/3 + Fn1/Fn2)**, прошивка — эмуляция **SpaceMouse Pro Wireless (cabled)**. Терминальное меню, ProgMode и формат параметров сохранены.

1. **Проверка разводки HES и полярностей**

   * Открой Serial‑монитор, нажми `Enter`, выбери режим **1** (или **10**) — «raw ADC».
   * Двигая ручку по одной оси, смотри, что шевелятся **ровно нужные пары** каналов (см. `PINLIST`).
   * Если при приближении магнита *значение растёт*, а должно **падать** — инвертируй соответствующую пару в `INVERTLIST` (обычно зеркально: `0&1`, `2&3`, `6&7`, `8&9`).
   * Повтори для всех трёх степеней свободы.

2. **Нулевая точка и «тихий» дрейф**

   * Режим **11** («Zeroing…»). Не трогай ручку, смотри предложенный `DEADZONE` и отметки *Axis not centered?*.
   * Поставь небольшую «мёртвую зону» — **3…6**. В конфиге: `#define DEADZONE N`, или через меню параметров (см. п. 7) → **Write to EEPROM**.

3. **Диапазоны MIN/MAX**

   * Режим **20** на ~20 с: активно покачай/пожми по всем осям.
   * Забери предложенные массивы `MINVALS`/`MAXVALS` и **впиши в `config.h`** (раздел «Third calibration»), **пересобери и залей**.
   * Признак, что диапазон занижен: в режимах 2/3/4 значения «упираются» раньше физического хода.

4. **Чувствительность**

   * Режим **4** (TX/TY/TZ/RX/RY/RZ). Добивайся, чтобы при полном ходе пики были в коридоре **±320…±350**.
   * Тюнинг: `SENS_TX/TY` (линейка), `SENS_PTZ/SENS_NTZ` (плюсовая/минусовая Z отдельно), `SENS_RX/RY/RZ` (повороты).
   * Вспомогательные «ворота»: `GATE_NTZ`, `GATE_RX/RY/RZ` — отрубает мелкий шум вокруг нуля (0 = выкл).

5. **Форма отклика (Modifier)**

   * `MODFUNC=0` — линейка.
   * `MODFUNC=1` — «квазиквадрат»: гасит мелочь вокруг нуля, оставляя контроль на больших отклонениях.
   * `MOD_A` влияет на «приплюснутость» у нуля (1.05…1.4), `MOD_B` — на рост к краю (1.1…1.35 для `MODFUNC=3`, но в этом форке по умолчанию **1**).
   * Проверяй в **3** (центрированные+deadzone) и **4** (скорости).

6. **Оси/инверсии/перестановки**

   * Если в САПР «влево» ощущается «вправо» — правь `INVX/INVY/INVZ` и `INVRX/INVRY/INVRZ`.
   * `SWITCHXY/SWITCHYZ` — обмен осей при надобности.
   * Для Windows + 3DxWare частые пресеты указаны в комментариях рядом с define’ами.

7. **Меню параметров и EEPROM (без перекомпиляции)**

   * Режим **30** → `1` (list), `2` (edit), `4` (write EEPROM), `7` (dump defines).
   * Порядок удобный: `2` — подправил / проверил в **4** — `4` (save) — при желании `7` (скопировал в `config.h`).

8. **Комбо‑кнопки (Fn1/Fn2 + 1/2/3)**

   * В этом форке реализованы слои: **база** (`BUTTONLIST`), **Fn1** (`BUTTONLIST_FN1`), **Fn2** (`BUTTONLIST_FN2`).
   * Соло‑нажатия Fn1/Fn2 отдают свои отдельные действия (настроены в базовом списке по индексам `KEY_FN1_IDX/KEY_FN2_IDX`).
   * Комбинации не «протекают» базовыми нажатиями; удержание поддерживает автоповтор на стороне HID.
   * Кнопки и слои задаются **в `config.h`**: `NUMKEYS`, `KEYLIST`, `NUMHIDKEYS`, `BUTTONLIST`, `BUTTONLIST_FN1`, `BUTTONLIST_FN2`, `KEY_FN1_IDX/KEY_FN2_IDX`.

9. **Дрифт‑компенсация**

   * Оставь мышь в покое: при `COMP_EN=1` нули подравниваются автоматически, не трогая твою «центровку» и чувствительности.
   * Тюнинг: `COMP_WAIT` (ожидание покоя), `COMP_NR` (длина усреднения), `COMP_MDIFF/COMP_CDIFF` (допустимые подвижки/смещения).

10. **Быстрый чек‑лист симптомов**

    * «Подвисает» одна из осей на краях → расширь `MINVALS/MAXVALS`.
    * Мелкая дрожь около нуля → чутка увеличь `DEADZONE` или `GATE_*`; подстрой `MODFUNC`.
    * Комбо срабатывают «двойным» нажатием → проверь актуальные файлы `spaceKeys.*` и `SpaceMouseHID.*` из форка (правки слоя/повтора/маски); при необходимости увеличь `DEBOUNCE_KEYS_MS`.

---

### Ручное центрирование (Fn1+Fn2)

Если устройство уже откалибровано, но «нулевая точка» немного уплыла, можно быстро пересвести ноль без пересборки и без потери чувствительности/диапазонов:

* **Зажмите одновременно Fn1 и Fn2 на ~2 секунды.**
* Сработает «мягкий zeroing»: вызывается та же логика, что и автокомпенсация дрейфа (re‑center), **не трогая** MIN/MAX, чувствительности, маппинг осей и EEPROM.
* Работает в любом режиме (в т.ч. вне меню), безопасно.

> Примечание: Авто‑zeroing (drift compensation) остаётся включённым и продолжает работать по заданным порогам `COMP_*`. Комбинация Fn1+Fn2 — это ручной триггер того же процесса, когда нужно «подровнять» ноль сразу.

## Справочник параметров (меню/EEPROM)

Ниже — параметры, видимые в **mode 30 → list/edit**. Типы: **INT**, **FLOAT**, **BOOL**.

#

### Комбинация Fn1+Fn2 — Zeroing

* **Что делает:** мгновенно инициирует мягкое центрирование (re‑center) как в авто‑компенсации дрейфа.
* **Что не делает:** не сбрасывает `MINVALS`/`MAXVALS`, не меняет `SENS_*`, `INV*`, не пишет в EEPROM.
* **Когда использовать:** если после длительной паузы ощущается микросмещение нуля — зажмите Fn1+Fn2 на ~2s.

## Движение и чувствительность

* **DEADZONE** *(INT)* — ширина «мертвой зоны» по центрированным значениям. Малые шумы в ноль. Реком.: **3…6**.
* **SENS_TX / SENS_TY** *(FLOAT)* — делитель чувствительности по X/Y трансляциям. **Меньше** → чувствительнее.
* **SENS_PTZ / SENS_NTZ** *(FLOAT)* — делители по **+Z / −Z** (раздельная калибровка «вниз/вверх»).
* **SENS_RX / SENS_RY / SENS_RZ** *(FLOAT)* — делители по поворотам (roll/pitch/yaw).
* **GATE_NTZ / GATE_RX / GATE_RY / GATE_RZ** *(INT)* — «ворота» около нуля; всё, что по модулю меньше — принудительно ноль. `0` = выкл.

### Модификатор кривой

* **MODFUNC** *(INT)* — 0: линейка; 1: `|x|^a·sign(x)`; 3: `tan(b·(|x|^a·sign(x)))/tan(b)` (в этом форке обычно 0/1).
* **MOD_A** *(FLOAT)* — экспонента «у нуля» (для 1 и 3). Больше → спокойнее около нуля. Типично **1.10…1.40**.
* **MOD_B** *(FLOAT)* — усиление к краям (для 3). Типично **1.10…1.35**.

### Направления/перестановки

* **INVX / INVY / INVZ / INVRX / INVRY / INVRZ** *(BOOL)* — инвертировать соответствующую ось.
* **SWITCHXY / SWITCHYZ** *(BOOL)* — обмен осей (перетасовать под конкретный софт/привычки).

### Эксклюзивный режим

* **EXCLUSIVE** *(BOOL)* — передавать **либо** трансляцию, **либо** вращение (что крупнее).
* **EXCL_HYST** *(INT)* — гистерезис, чтобы не «щёлкало» туда‑сюда (0 = выкл).
* **EXCL_PRIOZ** *(BOOL)* — «Z‑приоритет» для резистивных джойстиков (для HES обычно **0**).

### Дрифт‑компенсация (HES)

* **COMP_EN** *(BOOL)* — включить авто‑подравнивание нулей.
* **COMP_NR** *(INT)* — сколько выборок усреднять, когда устройство признано неподвижным.
* **COMP_WAIT** *(INT, ms)* — сколько ждать «тишину» перед компенсацией.
* **COMP_MDIFF** *(INT)* — предельная амплитуда дрожи «внутри окна», чтобы считать это дрейфом.
* **COMP_CDIFF** *(INT)* — доп. порог от центра: если ушли дальше — компенсацию не делать (считается реальным нажатием).

### Прочее

* **RAXIS_ECH / RAXIS_STR** — для режима «колесо как ось/клавиши» (у нас выключено, но параметры на месте для совместимости).

> Все эти параметры можно редактировать в **mode 30 → edit**, проверять в **mode 4**, сохранять в EEPROM (**mode 30 → write**), а затем выгружать текущие значения в виде `#define` (**mode 30 → list as defines**) для переноса в `config.h`.

---

> Примеры работы модификаторов кривой и подбор коэффициентов с визуализацией — в `modifierFunctions.html` (локальное HTML‑приложение, интерактивно демонстрирующее работу алгоритмов).

## Компиляция/линковка конфигурации кнопок (compile‑time)

Эти вещи **не** живут в EEPROM и задаются в `spacemouse-keys/config.h`:

* `NUMKEYS`, `KEYLIST` — сколько физических кнопок и на каких пинах.
* `NUMHIDKEYS` — сколько из них отдаём в HID‑массив.
* `BUTTONLIST` — базовый слой (индексы SM_* в HID‑отчёте).
* `BUTTONLIST_FN1`, `BUTTONLIST_FN2` — слои для комбо с Fn1/Fn2.
* `KEY_FN1_IDX`, `KEY_FN2_IDX` — индексы Fn‑кнопок (для соло‑действий и выбора слоя).
* `DEBOUNCE_KEYS_MS` — антидребезг.

После изменения этих `#define` → **пересборка и прошивка** обязательны.

## Button map (вид сверху контроллера)

Вид сверху (ориентир: USB сверху):

```
                                         USB
                                  -................
                KEY1              -              ..
                      .--      .........  . ........
                   .--. -+....                       ....
                  --.  ...        ...-.......-...        ...
                  .--..      ....                  ...       ..
     KEY2    .+.   .      ..                           ..      .
            +. .--     ..                                 ..     .
          --.  .     -.                                     ..     .
          +-. .    ..                .-------.                ..     .
            ..   ..             -.              ...             .    ..
       ... .    ..           ..                     ..           ..   ..
KEY3  .- .-.   ..          ..      .-..     ...       .           ..   ..
      -. ..   ..         .-     ..              ...     .          ..   ..
     .+  ..  ..         ..    ..                   ..    ..         ..   .
     .-+-.   -         ..   ..                      ..    ..        ..   ..
        ..  ..         .   ..                        ..    .         ..   .
       ..   -         -    .                          .    ..        ..   .
       ..   .         .    .                           .   ..         ..  .
       ..  ..         .    .                           -    .         ..  ..
       ..  ..         .    .                           -   ..         ..  ..
       ..  ..         -    .                          ..   ..         ..  .
        .   .         ..   ..                         .    ..         .   .
        ..  .          .    ..                       .    ..         ..   .
        ..  ..          .    ..                    ..    ..          ..  ..
         ..  .           ..    ..                ..     ..          ..   .
         ..   .            .      ..          .-.      -            .   .
          ..   .            ..                      ...            -   ..
           .    .              ..                 -.              -   ..
            ..   .                 .-..     .--.                 .   ..
              .   ..                                           ..   -+.
               .    ..                                       ..    .  --
                 .    .                                    ..   ..  .--
                   ..   ..                              ...    ..+---.   Fn1
                     ..    ...                      ....    ...    *
                        ...    .......       .......    .... --.
                           ....       .......       ...+-  .---
                                ....................     *--       Fn2
```

### Таблица соответствий

| Кнопка | Одиночное (Base)      | С Fn1                 | С Fn2                 |
| ------ | --------------------- | --------------------- | --------------------- |
| KEY1   | **1** *(SM_1)*        | **MENU** *(SM_MENU)*  | **ESC** *(SM_ESC)*    |
| KEY2   | **2** *(SM_2)*        | **FIT** *(SM_FIT)*    | **CTRL** *(SM_CTRL)*  |
| KEY3   | **3** *(SM_3)*        | **LOCK** *(SM_ROT)*   | **ALT** *(SM_ALT)*    |
| Fn1    | **SHIFT** *(SM_SHFT)* | —                     | **Fn1+Fn2 = Zeroing** |
| Fn2    | **4** *(SM_4)*        | **Fn1+Fn2 = Zeroing** | —                     |

> **Примечания**
>
> * **Fn‑кнопки** работают как **модификаторы слоёв**: зажатый Fn1 или Fn2 временно переключает KEY1..KEY3 на альтернативные функции из соответствующего слоя. Одиночное нажатие Fn1/Fn2 тоже отправляет своё действие (см. таблицу).
> * **Fn1+Fn2** вместе запускают «Zeroing» (мягкое рецентрирование по дрейфу). Это **не** трогает MIN/MAX, чувствительности `SENS_*`, EEPROM-конфиг и т.п.; только пересчитывается текущий ноль, как при дрейф‑компенсации.
> * Раскладка изменяемая: при необходимости её можно настроить в `spacemouse-keys/config.h` через списки `BUTTONLIST`, `BUTTONLIST_FN1`, `BUTTONLIST_FN2` и индексы `KEY_FN1_IDX/KEY_FN2_IDX`. Для драйвера/ПО соответствия API показаны в скобках *(SM_…)*.
